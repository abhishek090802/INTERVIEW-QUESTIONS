//recursive way with TC=O(N) and SC=O(H) as the height of the tree as the recursive stack space
class Solution {
public:
    void helper(TreeNode*root,vector<int>&ans)
    {
        if(!root) return;
        ans.push_back(root->val);
        helper(root->left,ans);
        helper(root->right,ans);
    }
    vector<int> preorderTraversal(TreeNode* root) {
    vector<int>ans;
        helper(root,ans);
        return ans;
    }
};

//iterative preorder traversal with TC=O(N) and SC=O(N) of stack space
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        //iterative preorder traversal TC=O(N) and SC=O(N)
      vector<int>preorder;
        if(!root) return preorder;  //as is algo me ham pahle stack me push kar rahe hai then agge ke actions thats why we have to check whether root is null or not
        stack<TreeNode*>st;
        TreeNode*node;
      st.push(root);
        while(!st.empty())
        {
            node=st.top();
            st.pop();
            preorder.push_back(node->val);
            if(node->right!=NULL) 
                st.push(node->right);
            if(node->left!=NULL)
            st.push(node->left);
        }
        return preorder;
    }
};

//morris traversal with the TC=O(N)+O(N) and SC=O(1)
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
      //using morris traversal TC=O(N) and SC=O(1)
        vector<int>preorder;
        TreeNode*cur=root;
        while(cur!=NULL)
        {
            if(cur->left==NULL)
            {
                preorder.push_back(cur->val); cur=cur->right; 
            }
            else {
                TreeNode*prev=cur->left; 
                while(prev->right and prev->right!=cur) {prev=prev->right;}
                if(prev->right==NULL)  
                {
                    prev->right=cur;
                    preorder.push_back(cur->val);
                    cur=cur->left;
                }
                if(prev->right==cur)
                {
                    prev->right=NULL;
                 // preorder.push_back(cur->val);
                    cur=cur->right;
                }
            }
        }
        return preorder;
    }
};
